{"version":3,"file":"utilities.js","sourceRoot":"","sources":["../../src/lib/utilities.ts"],"names":[],"mappings":"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","sourcesContent":["import * as tikTokSchema from '@/types/tiktok-schema';\nimport { MessageFns, ProtoMessageFetchResult, WebcastPushFrame } from '@/types/tiktok-schema';\nimport {\n    DecodedWebcastPushFrame,\n    IWebcastDeserializeConfig,\n    WebcastEventMessage,\n    WebcastMessage\n} from '@/types/client';\nimport * as zlib from 'node:zlib';\nimport * as util from 'node:util';\nimport { InvalidSchemaNameError, InvalidUniqueIdError } from '@/types/errors';\nimport { DevicePreset } from '@/lib/config';\n\nconst unzip = util.promisify(zlib.unzip);\nconst webcastEvents: (keyof WebcastEventMessage)[] = Object.keys(tikTokSchema).filter((message) => message.startsWith('Webcast')) as (keyof WebcastEventMessage)[];\n\nexport const WebcastDeserializeConfig: IWebcastDeserializeConfig = {\n    skipMessageTypes: []\n};\n\n/**\n * Find the messages defined in the TikTok protobuf schema\n */\nasync function getTikTokSchemaNames(): Promise<string[]> {\n    return Object.keys(tikTokSchema);\n}\n\n/**\n * Find the Webcast messages defined in the TikTok protobuf schema\n */\nasync function getWebcastEvents(): Promise<string[]> {\n    return (await getTikTokSchemaNames()).filter((message) => message.startsWith('Webcast'));\n}\n\nexport function deserializeMessage<T extends keyof WebcastMessage>(\n    protoName: T,\n    binaryMessage: Buffer\n): WebcastMessage[T] {\n\n    const messageFn: MessageFns<WebcastMessage[T]> | undefined = tikTokSchema[protoName as string];\n    if (!messageFn) throw new InvalidSchemaNameError(`Invalid schema name: ${protoName}`);\n    const deserializedMessage: WebcastMessage[T] = messageFn.decode(binaryMessage);\n\n    // Handle ProtoMessageFetchResult nested messages\n    if (protoName === 'ProtoMessageFetchResult') {\n        for (const message of (deserializedMessage as ProtoMessageFetchResult).messages || []) {\n            if (WebcastDeserializeConfig.skipMessageTypes.includes(message.type as keyof WebcastEventMessage)) {\n                continue;\n            }\n\n            if (!webcastEvents.includes(message.type as keyof WebcastEventMessage)) {\n                continue;\n            }\n\n            message.decodedData = {\n                type: message.type as keyof WebcastEventMessage,\n                data: deserializeMessage(message.type as keyof WebcastEventMessage, Buffer.from(message.payload))\n            } as any;\n\n        }\n    }\n\n    return deserializedMessage;\n}\n\n\nexport async function deserializeWebSocketMessage(binaryMessage: Uint8Array): Promise<DecodedWebcastPushFrame> {\n    // Websocket messages are in a container which contains additional data\n    // Message type 'msg' represents a normal WebcastResponse\n    const rawWebcastWebSocketMessage = WebcastPushFrame.decode(binaryMessage);\n    let protoMessageFetchResult: ProtoMessageFetchResult | undefined = undefined;\n\n    if (rawWebcastWebSocketMessage.type === 'msg') {\n        let binary: Uint8Array = rawWebcastWebSocketMessage.binary;\n\n        // Decompress binary (if gzip compressed)\n        // https://www.rfc-editor.org/rfc/rfc1950.html\n        if (binary && binary.length > 2 && binary[0] === 0x1f && binary[1] === 0x8b && binary[2] === 0x08) {\n            rawWebcastWebSocketMessage.binary = await unzip(binary);\n        }\n\n        protoMessageFetchResult = deserializeMessage('ProtoMessageFetchResult', Buffer.from(rawWebcastWebSocketMessage.binary));\n    }\n\n    const decodedContainer: DecodedWebcastPushFrame = rawWebcastWebSocketMessage;\n    decodedContainer.protoMessageFetchResult = protoMessageFetchResult;\n    return decodedContainer;\n\n}\n\nexport function validateAndNormalizeUniqueId(uniqueId: string) {\n    if (typeof uniqueId !== 'string') {\n        throw new InvalidUniqueIdError('Missing or invalid value for \\'uniqueId\\'. Please provide the username from TikTok URL.');\n    }\n\n    // Support full URI\n    uniqueId = uniqueId.replace('https://www.tiktok.com/', '');\n    uniqueId = uniqueId.replace('/live', '');\n    uniqueId = uniqueId.replace('@', '');\n    uniqueId = uniqueId.trim();\n    return uniqueId;\n}\n\n\nexport function userAgentToDevicePreset(userAgent: string): DevicePreset {\n    const firstSlash = userAgent.indexOf('/');\n    const browserName = userAgent.substring(0, firstSlash);\n    const browserVersion = userAgent.substring(firstSlash + 1);\n\n    return {\n        user_agent: userAgent,\n        browser_name: browserName,\n        browser_version: browserVersion,\n        browser_platform: userAgent.includes('Macintosh') ? 'MacIntel' : 'Win32',\n        os: userAgent.includes('Macintosh') ? 'mac' : 'windows'\n    };\n}\n\nexport function generateDeviceId() {\n    let digits = '';\n    for (let i = 0; i < 19; i++) {\n        digits += Math.floor(Math.random() * 10);\n    }\n    return digits;\n}\n"]}