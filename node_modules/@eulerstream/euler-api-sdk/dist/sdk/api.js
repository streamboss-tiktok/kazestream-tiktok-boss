"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebcastApi = exports.WebcastApiFactory = exports.WebcastApiFp = exports.WebcastApiAxiosParamCreator = exports.TikTokApi = exports.TikTokApiFactory = exports.TikTokApiFp = exports.TikTokApiAxiosParamCreator = exports.UpdateKeyUpdateByEnum = exports.GetKeyRetrieveByEnum = exports.DeleteKeyDeleteByEnum = exports.AuthenticationApi = exports.AuthenticationApiFactory = exports.AuthenticationApiFp = exports.AuthenticationApiAxiosParamCreator = exports.AnalyticsApi = exports.AnalyticsApiFactory = exports.AnalyticsApiFp = exports.AnalyticsApiAxiosParamCreator = exports.AlertsApi = exports.AlertsApiFactory = exports.AlertsApiFp = exports.AlertsApiAxiosParamCreator = exports.AlertTargetsApi = exports.AlertTargetsApiFactory = exports.AlertTargetsApiFp = exports.AlertTargetsApiAxiosParamCreator = exports.RetrieveAggregateUsagePeriodEnum = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.LogRequestMethod = exports.LiveClient = exports.ISignTikTokUrlBodyTypeEnum = exports.ISignTikTokUrlBodyMethodEnum = exports.IAlertTargetStatus = exports.IAlertTargetFormat = exports.ApiRoutes = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
exports.ApiRoutes = {
    ApiLive: 'api-live',
    InfoByUser: 'info-by-user'
};
/**
 *
 * @export
 * @enum {number}
 */
exports.IAlertTargetFormat = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 *
 * @export
 * @enum {number}
 */
exports.IAlertTargetStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_4: 4
};
exports.ISignTikTokUrlBodyMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Options: 'OPTIONS',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD'
};
exports.ISignTikTokUrlBodyTypeEnum = {
    Fetch: 'fetch',
    Xhr: 'xhr'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.LiveClient = {
    TtliveJava: 'ttlive-java',
    TtliveNode: 'ttlive-node',
    TtlivePython: 'ttlive-python',
    TtliveRust: 'ttlive-rust',
    TtliveGo: 'ttlive-go',
    TtliveOther: 'ttlive-other'
};
/**
 *
 * @export
 * @enum {number}
 */
exports.LogRequestMethod = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage: async (accountId, from, to, apiKeyId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'accountId', accountId);
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'to', to);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/page_count`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from instanceof Date) ?
                    from.toISOString() :
                    from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = (to instanceof Date) ?
                    to.toISOString() :
                    to;
            }
            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage: async (accountId, from, to, apiKeyId, page, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'accountId', accountId);
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'to', to);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from instanceof Date) ?
                    from.toISOString() :
                    from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = (to instanceof Date) ?
                    to.toISOString() :
                    to;
            }
            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage: async (accountId, period, value, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'accountId', accountId);
            // verify required parameter 'period' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'period', period);
            // verify required parameter 'value' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'value', value);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/aggregate`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countSignUsage(accountId, from, to, apiKeyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countSignUsage(accountId, from, to, apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.countSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignUsage(accountId, from, to, apiKeyId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignUsage(accountId, from, to, apiKeyId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.getSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAggregateUsage(accountId, period, value, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAggregateUsage(accountId, period, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.retrieveAggregateUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage(accountId, from, to, apiKeyId, options) {
            return localVarFp.countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage(accountId, from, to, apiKeyId, page, options) {
            return localVarFp.getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage(accountId, period, value, options) {
            return localVarFp.retrieveAggregateUsage(accountId, period, value, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    countSignUsage(accountId, from, to, apiKeyId, options) {
        return (0, exports.AccountsApiFp)(this.configuration).countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getSignUsage(accountId, from, to, apiKeyId, page, options) {
        return (0, exports.AccountsApiFp)(this.configuration).getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAggregateUsage(accountId, period, value, options) {
        return (0, exports.AccountsApiFp)(this.configuration).retrieveAggregateUsage(accountId, period, value, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * @export
 */
exports.RetrieveAggregateUsagePeriodEnum = {
    Hour: 'hour',
    Day: 'day'
};
/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
const AlertTargetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId, alertId, iAlertTargetConfigBase, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'alertId', alertId);
            // verify required parameter 'iAlertTargetConfigBase' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'iAlertTargetConfigBase', iAlertTargetConfigBase);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iAlertTargetConfigBase, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId, alertId, targetId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'alertId', alertId);
            // verify required parameter 'targetId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'targetId', targetId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listAlertTargets', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('listAlertTargets', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId, alertId, targetId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'alertId', alertId);
            // verify required parameter 'targetId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'targetId', targetId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertTargetsApiAxiosParamCreator = AlertTargetsApiAxiosParamCreator;
/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
const AlertTargetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertTargetsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.createAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId, alertId, targetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.deleteAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.listAlertTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId, alertId, targetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.testAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertTargetsApiFp = AlertTargetsApiFp;
/**
 * AlertTargetsApi - factory interface
 * @export
 */
const AlertTargetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertTargetsApiFp)(configuration);
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options) {
            return localVarFp.createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId, alertId, targetId, options) {
            return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId, alertId, options) {
            return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId, alertId, targetId, options) {
            return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertTargetsApiFactory = AlertTargetsApiFactory;
/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
class AlertTargetsApi extends base_1.BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    deleteAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    listAlertTargets(accountId, alertId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    testAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertTargetsApi = AlertTargetsApi;
/**
 * AlertsApi - axios parameter creator
 * @export
 */
const AlertsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a creator alert. These alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId, iAlertConfigBase, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAlert', 'accountId', accountId);
            // verify required parameter 'iAlertConfigBase' is not null or undefined
            (0, common_1.assertParamExists)('createAlert', 'iAlertConfigBase', iAlertConfigBase);
            const localVarPath = `/accounts/{account_id}/alerts/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iAlertConfigBase, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listAlerts', 'accountId', accountId);
            const localVarPath = `/accounts/{account_id}/alerts/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAlert', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAlert', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertsApiAxiosParamCreator = AlertsApiAxiosParamCreator;
/**
 * AlertsApi - functional programming interface
 * @export
 */
const AlertsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a creator alert. These alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId, iAlertConfigBase, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, iAlertConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.createAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {number} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.retrieveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertsApiFp = AlertsApiFp;
/**
 * AlertsApi - factory interface
 * @export
 */
const AlertsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertsApiFp)(configuration);
    return {
        /**
         * Create a creator alert. These alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId, iAlertConfigBase, options) {
            return localVarFp.createAlert(accountId, iAlertConfigBase, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId, options) {
            return localVarFp.listAlerts(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId, alertId, options) {
            return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertsApiFactory = AlertsApiFactory;
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
class AlertsApi extends base_1.BaseAPI {
    /**
     * Create a creator alert. These alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    createAlert(accountId, iAlertConfigBase, options) {
        return (0, exports.AlertsApiFp)(this.configuration).createAlert(accountId, iAlertConfigBase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    listAlerts(accountId, options) {
        return (0, exports.AlertsApiFp)(this.configuration).listAlerts(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    retrieveAlert(accountId, alertId, options) {
        return (0, exports.AlertsApiFp)(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertsApi = AlertsApi;
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
const AnalyticsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch a webcast URL for a given room ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options = {}) => {
            const localVarPath = `/analytics/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options = {}) => {
            const localVarPath = `/analytics/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve stats as an SVG
         * @param {LogRequestMethod} statName Name of the stat to retrieve
         * @param {string} [labelColour] Specify label colour in SVG
         * @param {string} [valueColour] Specify value colour in SVG
         * @param {number} [hours] The number of hours to retrieve the stat for
         * @param {LiveClient} [client] The client to filter for
         * @param {boolean} [json] Add the ability to retrieve the pip as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pips: async (statName, labelColour, valueColour, hours, client, json, options = {}) => {
            // verify required parameter 'statName' is not null or undefined
            (0, common_1.assertParamExists)('pips', 'statName', statName);
            const localVarPath = `/analytics/pips/{statName}`
                .replace(`{${"statName"}}`, encodeURIComponent(String(statName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (labelColour !== undefined) {
                localVarQueryParameter['labelColour'] = labelColour;
            }
            if (valueColour !== undefined) {
                localVarQueryParameter['valueColour'] = valueColour;
            }
            if (hours !== undefined) {
                localVarQueryParameter['hours'] = hours;
            }
            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }
            if (json !== undefined) {
                localVarQueryParameter['json'] = json;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AnalyticsApiAxiosParamCreator = AnalyticsApiAxiosParamCreator;
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
const AnalyticsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AnalyticsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch a webcast URL for a given room ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.fetchAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve stats as an SVG
         * @param {LogRequestMethod} statName Name of the stat to retrieve
         * @param {string} [labelColour] Specify label colour in SVG
         * @param {string} [valueColour] Specify value colour in SVG
         * @param {number} [hours] The number of hours to retrieve the stat for
         * @param {LiveClient} [client] The client to filter for
         * @param {boolean} [json] Add the ability to retrieve the pip as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pips(statName, labelColour, valueColour, hours, client, json, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pips(statName, labelColour, valueColour, hours, client, json, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.pips']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AnalyticsApiFp = AnalyticsApiFp;
/**
 * AnalyticsApi - factory interface
 * @export
 */
const AnalyticsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AnalyticsApiFp)(configuration);
    return {
        /**
         * Fetch a webcast URL for a given room ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options) {
            return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options) {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve stats as an SVG
         * @param {LogRequestMethod} statName Name of the stat to retrieve
         * @param {string} [labelColour] Specify label colour in SVG
         * @param {string} [valueColour] Specify value colour in SVG
         * @param {number} [hours] The number of hours to retrieve the stat for
         * @param {LiveClient} [client] The client to filter for
         * @param {boolean} [json] Add the ability to retrieve the pip as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pips(statName, labelColour, valueColour, hours, client, json, options) {
            return localVarFp.pips(statName, labelColour, valueColour, hours, client, json, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AnalyticsApiFactory = AnalyticsApiFactory;
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends base_1.BaseAPI {
    /**
     * Fetch a webcast URL for a given room ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    fetchAgents(options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getHosts(options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve stats as an SVG
     * @param {LogRequestMethod} statName Name of the stat to retrieve
     * @param {string} [labelColour] Specify label colour in SVG
     * @param {string} [valueColour] Specify value colour in SVG
     * @param {number} [hours] The number of hours to retrieve the stat for
     * @param {LiveClient} [client] The client to filter for
     * @param {boolean} [json] Add the ability to retrieve the pip as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    pips(statName, labelColour, valueColour, hours, client, json, options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).pips(statName, labelColour, valueColour, hours, client, json, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
const AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId, jWTCreateConfig, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createJWT', 'accountId', accountId);
            // verify required parameter 'jWTCreateConfig' is not null or undefined
            (0, common_1.assertParamExists)('createJWT', 'jWTCreateConfig', jWTCreateConfig);
            const localVarPath = `/accounts/{account_id}/jwt/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jWTCreateConfig, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId, iApiKeyConfigBase, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createKey', 'accountId', accountId);
            // verify required parameter 'iApiKeyConfigBase' is not null or undefined
            (0, common_1.assertParamExists)('createKey', 'iApiKeyConfigBase', iApiKeyConfigBase);
            const localVarPath = `/accounts/{account_id}/api_keys/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iApiKeyConfigBase, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId, deleteBy, deleteParam, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'accountId', accountId);
            // verify required parameter 'deleteBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'deleteBy', deleteBy);
            // verify required parameter 'deleteParam' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'deleteParam', deleteParam);
            const localVarPath = `/accounts/{account_id}/api_keys/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (deleteBy !== undefined) {
                localVarQueryParameter['delete_by'] = deleteBy;
            }
            if (deleteParam !== undefined) {
                localVarQueryParameter['delete_param'] = deleteParam;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId, retrieveParam, retrieveBy, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getKey', 'accountId', accountId);
            // verify required parameter 'retrieveParam' is not null or undefined
            (0, common_1.assertParamExists)('getKey', 'retrieveParam', retrieveParam);
            const localVarPath = `/accounts/{account_id}/api_keys/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (retrieveBy !== undefined) {
                localVarQueryParameter['retrieve_by'] = retrieveBy;
            }
            if (retrieveParam !== undefined) {
                localVarQueryParameter['retrieve_param'] = retrieveParam;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listKeys', 'accountId', accountId);
            const localVarPath = `/accounts/{account_id}/api_keys/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId, updateBy, updateParam, iApiKeyConfigBase, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'accountId', accountId);
            // verify required parameter 'updateBy' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateBy', updateBy);
            // verify required parameter 'updateParam' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateParam', updateParam);
            // verify required parameter 'iApiKeyConfigBase' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'iApiKeyConfigBase', iApiKeyConfigBase);
            const localVarPath = `/accounts/{account_id}/api_keys/update`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (updateBy !== undefined) {
                localVarQueryParameter['update_by'] = updateBy;
            }
            if (updateParam !== undefined) {
                localVarQueryParameter['update_param'] = updateParam;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iApiKeyConfigBase, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AuthenticationApiAxiosParamCreator = AuthenticationApiAxiosParamCreator;
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
const AuthenticationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthenticationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId, jWTCreateConfig, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.createJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId, iApiKeyConfigBase, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, iApiKeyConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.createKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId, deleteBy, deleteParam, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId, retrieveParam, retrieveBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.getKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.listKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.updateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AuthenticationApiFp = AuthenticationApiFp;
/**
 * AuthenticationApi - factory interface
 * @export
 */
const AuthenticationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthenticationApiFp)(configuration);
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId, jWTCreateConfig, options) {
            return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId, iApiKeyConfigBase, options) {
            return localVarFp.createKey(accountId, iApiKeyConfigBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId, deleteBy, deleteParam, options) {
            return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId, retrieveParam, retrieveBy, options) {
            return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId, options) {
            return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options) {
            return localVarFp.updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthenticationApiFactory = AuthenticationApiFactory;
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends base_1.BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createJWT(accountId, jWTCreateConfig, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createKey(accountId, iApiKeyConfigBase, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).createKey(accountId, iApiKeyConfigBase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    deleteKey(accountId, deleteBy, deleteParam, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getKey(accountId, retrieveParam, retrieveBy, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    listKeys(accountId, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * @export
 */
exports.DeleteKeyDeleteByEnum = {
    Value: 'value',
    Name: 'name',
    Id: 'id'
};
/**
 * @export
 */
exports.GetKeyRetrieveByEnum = {
    Value: 'value',
    Name: 'name',
    Id: 'id'
};
/**
 * @export
 */
exports.UpdateKeyUpdateByEnum = {
    Value: 'value',
    Name: 'name',
    Id: 'id'
};
/**
 * TikTokApi - axios parameter creator
 * @export
 */
const TikTokApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
         * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTikTokUrl: async (iSignTikTokUrlBody, preferredAgentIds, options = {}) => {
            // verify required parameter 'iSignTikTokUrlBody' is not null or undefined
            (0, common_1.assertParamExists)('signTikTokUrl', 'iSignTikTokUrlBody', iSignTikTokUrlBody);
            const localVarPath = `/tiktok/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (preferredAgentIds !== undefined) {
                localVarQueryParameter['preferred_agent_ids'] = preferredAgentIds;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iSignTikTokUrlBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TikTokApiAxiosParamCreator = TikTokApiAxiosParamCreator;
/**
 * TikTokApi - functional programming interface
 * @export
 */
const TikTokApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TikTokApiAxiosParamCreator)(configuration);
    return {
        /**
         * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
         * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokApi.signTikTokUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TikTokApiFp = TikTokApiFp;
/**
 * TikTokApi - factory interface
 * @export
 */
const TikTokApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TikTokApiFp)(configuration);
    return {
        /**
         * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
         * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options) {
            return localVarFp.signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TikTokApiFactory = TikTokApiFactory;
/**
 * TikTokApi - object-oriented interface
 * @export
 * @class TikTokApi
 * @extends {BaseAPI}
 */
class TikTokApi extends base_1.BaseAPI {
    /**
     * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
     * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokApi
     */
    signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options) {
        return (0, exports.TikTokApiFp)(this.configuration).signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TikTokApi = TikTokApi;
/**
 * WebcastApi - axios parameter creator
 * @export
 */
const WebcastApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
         * @param {string} client The client ID
         * @param {string} [roomId] The room ID to fetch the webcast URL for
         * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
         * @param {string} [cursor] The cursor to fetch the webcast URL for
         * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
         * @param {string} [userAgent] Override the user agent used in the signature
         * @param {string} [preferredAgentIds] The preferred agent ID
         * @param {string} [ttTargetIdc] The target IDC to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options = {}) => {
            // verify required parameter 'client' is not null or undefined
            (0, common_1.assertParamExists)('fetchWebcastURL', 'client', client);
            const localVarPath = `/webcast/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }
            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }
            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }
            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }
            if (preferredAgentIds !== undefined) {
                localVarQueryParameter['preferred_agent_ids'] = preferredAgentIds;
            }
            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options = {}) => {
            const localVarPath = `/webcast/rate_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room Id for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomId', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomInfo', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (iWebcastRoomChatPayload, options = {}) => {
            // verify required parameter 'iWebcastRoomChatPayload' is not null or undefined
            (0, common_1.assertParamExists)('sendRoomChat', 'iWebcastRoomChatPayload', iWebcastRoomChatPayload);
            const localVarPath = `/webcast/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iWebcastRoomChatPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
         * @param {string} [preferredAgentId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (iSignTikTokUrlBody, preferredAgentId, options = {}) => {
            // verify required parameter 'iSignTikTokUrlBody' is not null or undefined
            (0, common_1.assertParamExists)('signWebcastUrl', 'iSignTikTokUrlBody', iSignTikTokUrlBody);
            const localVarPath = `/webcast/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (preferredAgentId !== undefined) {
                localVarQueryParameter['preferred_agent_id'] = preferredAgentId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(iSignTikTokUrlBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebcastApiAxiosParamCreator = WebcastApiAxiosParamCreator;
/**
 * WebcastApi - functional programming interface
 * @export
 */
const WebcastApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WebcastApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
         * @param {string} client The client ID
         * @param {string} [roomId] The room ID to fetch the webcast URL for
         * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
         * @param {string} [cursor] The cursor to fetch the webcast URL for
         * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
         * @param {string} [userAgent] Override the user agent used in the signature
         * @param {string} [preferredAgentIds] The preferred agent ID
         * @param {string} [ttTargetIdc] The target IDC to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebcastApi.fetchWebcastURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebcastApi.getRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room Id for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebcastApi.retrieveRoomId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebcastApi.retrieveRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(iWebcastRoomChatPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(iWebcastRoomChatPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebcastApi.sendRoomChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
         * @param {string} [preferredAgentId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebcastApi.signWebcastUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.WebcastApiFp = WebcastApiFp;
/**
 * WebcastApi - factory interface
 * @export
 */
const WebcastApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WebcastApiFp)(configuration);
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
         * @param {string} client The client ID
         * @param {string} [roomId] The room ID to fetch the webcast URL for
         * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
         * @param {string} [cursor] The cursor to fetch the webcast URL for
         * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
         * @param {string} [userAgent] Override the user agent used in the signature
         * @param {string} [preferredAgentIds] The preferred agent ID
         * @param {string} [ttTargetIdc] The target IDC to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options) {
            return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options) {
            return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room Id for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId, options) {
            return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId, options) {
            return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(iWebcastRoomChatPayload, options) {
            return localVarFp.sendRoomChat(iWebcastRoomChatPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
         * @param {string} [preferredAgentId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options) {
            return localVarFp.signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WebcastApiFactory = WebcastApiFactory;
/**
 * WebcastApi - object-oriented interface
 * @export
 * @class WebcastApi
 * @extends {BaseAPI}
 */
class WebcastApi extends base_1.BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
     * @param {string} client The client ID
     * @param {string} [roomId] The room ID to fetch the webcast URL for
     * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
     * @param {string} [cursor] The cursor to fetch the webcast URL for
     * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
     * @param {string} [userAgent] Override the user agent used in the signature
     * @param {string} [preferredAgentIds] The preferred agent ID
     * @param {string} [ttTargetIdc] The target IDC to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options) {
        return (0, exports.WebcastApiFp)(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    getRateLimits(options) {
        return (0, exports.WebcastApiFp)(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch Room Id for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    retrieveRoomId(uniqueId, options) {
        return (0, exports.WebcastApiFp)(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    retrieveRoomInfo(uniqueId, options) {
        return (0, exports.WebcastApiFp)(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
     * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    sendRoomChat(iWebcastRoomChatPayload, options) {
        return (0, exports.WebcastApiFp)(this.configuration).sendRoomChat(iWebcastRoomChatPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
     * @param {string} [preferredAgentId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options) {
        return (0, exports.WebcastApiFp)(this.configuration).signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WebcastApi = WebcastApi;
//# sourceMappingURL=api.js.map